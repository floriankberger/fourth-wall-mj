<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mahjong Scorer - Fourth Wall</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Confetti animation */
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -10px;
            z-index: 9999;
            pointer-events: none;
            animation: confetti-fall 3s linear forwards;
        }

        /* Victory glow animation */
        @keyframes victory-glow {
            0%, 100% {
                box-shadow: 0 0 30px rgba(212, 175, 55, 0.4), 0 8px 24px rgba(0,0,0,0.15);
            }
            50% {
                box-shadow: 0 0 60px rgba(212, 175, 55, 0.7), 0 8px 24px rgba(0,0,0,0.15);
            }
        }

        .victory-glow {
            animation: victory-glow 2s ease-in-out infinite;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #2d5016;
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0,0,0,.03) 2px,
                    rgba(0,0,0,.03) 4px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 2px,
                    rgba(0,0,0,.03) 2px,
                    rgba(0,0,0,.03) 4px
                );
            color: #2c3e50;
            min-height: 100vh;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #1a3510 0%, #2d5016 100%);
            border-bottom: 3px solid #d4af37;
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .header-content {
            max-width: 600px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .menu-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            color: #f8f5e6;
        }

        /* Main Container */
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Screen Management */
        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        /* Home Screen */
        .main-actions {
            display: grid;
            gap: 16px;
            margin-top: 20px;
        }

        .action-card {
            background: linear-gradient(135deg, rgba(248, 245, 230, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%);
            border: 3px solid rgba(212, 175, 55, 0.4);
            border-radius: 12px;
            padding: 24px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .action-card:hover {
            border-color: #d4af37;
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.25);
            background: linear-gradient(135deg, rgba(248, 245, 230, 1) 0%, rgba(255, 255, 255, 1) 100%);
        }

        .action-card:active {
            transform: translateY(-2px);
        }

        .action-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .action-icon {
            font-size: 48px;
            flex-shrink: 0;
        }

        .action-content h2 {
            font-size: 20px;
            margin-bottom: 0;
            color: #2c3e50;
            line-height: 1;
        }

        .action-content p {
            font-size: 14px;
            color: #6c757d;
            line-height: 1.4;
        }

        /* STICKY TILE COUNTER */
        .sticky-tile-counter {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            border: 2px solid #e1e4e8;
            position: sticky;
            top: 85px;
            z-index: 90;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        /* Tile Selector */
        .tile-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            border: 2px solid #e1e4e8;
        }

        .tile-section h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .tile-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .tile-grid.winds {
            grid-template-columns: repeat(4, 1fr);
        }

        .tile-grid.dragons {
            grid-template-columns: repeat(3, 1fr);
        }

        .tile-grid.flowers {
            grid-template-columns: repeat(4, 1fr);
        }

        .tile-option {
            background: #f8f9fa;
            border: 2px solid #e1e4e8;
            border-radius: 8px;
            padding: 12px 6px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 20px;
            font-weight: 600;
            position: relative;
        }

        .tile-option:hover:not(.disabled) {
            background: #e9ecef;
            transform: translateY(-2px);
        }

        .tile-option.disabled {
            opacity: 0.2;
            cursor: not-allowed;
        }

        .tile-option.selected {
            background: #769656;
            color: white;
            border-color: #769656;
        }

        .tile-option.character {
            border-color: #dc3545;
            color: #dc3545;
        }

        .tile-option.bamboo {
            border-color: #28a745;
            color: #28a745;
        }

        .tile-option.dot {
            border-color: #007bff;
            color: #007bff;
        }

        .tile-option.wind {
            border-color: #2c3e50;
            color: #2c3e50;
        }

        .tile-option.dragon {
            border-color: #d4af37;
            color: #d4af37;
        }

        .tile-option.selected.character,
        .tile-option.selected.bamboo,
        .tile-option.selected.dot,
        .tile-option.selected.wind,
        .tile-option.selected.dragon {
            color: white;
            border-color: #769656;
        }

        .tile-count {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
        }

        .tile-count.zero {
            display: none;
        }

        /* Selected tiles display */
        .selected-tiles-display {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 6px;
        }

        .selected-tiles-display.empty {
            color: #6c757d;
            font-size: 13px;
        }

        .selected-tile {
            width: auto;
            min-width: 36px;
            height: 44px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #dee2e6;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 600;
            padding: 2px 6px;
            color: #2c3e50;
        }

        .selected-tile.bamboo { 
            border-color: #28a745; 
            color: #28a745; 
            background: linear-gradient(135deg, #f0fff4 0%, #e8f5e9 100%);
        }
        .selected-tile.character { 
            border-color: #dc3545; 
            color: #dc3545; 
            background: linear-gradient(135deg, #fff5f5 0%, #ffe5e5 100%);
        }
        .selected-tile.dot { 
            border-color: #007bff; 
            color: #007bff; 
            background: linear-gradient(135deg, #f0f8ff 0%, #e3f2fd 100%);
        }
        .selected-tile.wind { 
            border-color: #2c3e50; 
            color: #2c3e50; 
            font-weight: 700; 
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }
        .selected-tile.dragon { 
            border-color: #d4af37; 
            color: #d4af37; 
            font-weight: 700; 
            background: linear-gradient(135deg, #fffef0 0%, #fef9e7 100%);
        }
        .selected-tile.flower {
            border-color: #e91e63;
            color: #e91e63;
            background: linear-gradient(135deg, #fff0f5 0%, #ffe4f2 100%);
        }

        /* Toggle Section */
        .toggle-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            border: 1px solid #e1e4e8;
        }

        .toggle-section h3 {
            font-size: 16px;
            margin-bottom: 16px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .toggle-grid.single {
            grid-template-columns: 1fr;
        }

        .toggle-option {
            background: #f8f9fa;
            border: 2px solid #e1e4e8;
            border-radius: 8px;
            padding: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-weight: 500;
        }

        .toggle-option:hover {
            background: #f0f0f0;
        }

        .toggle-option.selected {
            background: #769656;
            color: white;
            border-color: #769656;
        }

        .toggle-option .label {
            font-size: 15px;
        }

        .toggle-option .sublabel {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 4px;
        }

        /* Button Styles */
        .btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #769656;
            color: white;
        }

        .btn-primary:hover {
            background: #5f7a44;
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: white;
            color: #6c757d;
            border: 2px solid #e1e4e8;
        }

        .btn-secondary:hover {
            background: #f8f9fa;
        }

        /* Results Screen */
        .result-hero {
            background: linear-gradient(135deg, rgba(248, 245, 230, 0.98) 0%, rgba(255, 253, 245, 0.98) 100%);
            color: #2d5016;
            border-radius: 16px;
            padding: 20px 20px;
            text-align: center;
            margin-bottom: 12px;
            border: 4px solid #d4af37;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .result-hero::before {
            content: '';
            position: absolute;
            top: 6px;
            left: 6px;
            right: 6px;
            bottom: 6px;
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            pointer-events: none;
        }

        .result-hero::after {
            content: '🏆';
            position: absolute;
            top: 12px;
            right: 12px;
            font-size: 32px;
            opacity: 0.1;
        }

        .coin {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .coin-1 { background: white; color: #2c3e50; border-color: #dee2e6; }
        .coin-2 { background: #007bff; color: white; }
        .coin-5 { background: #28a745; color: white; }
        .coin-10 { background: #dc3545; color: white; }
        .coin-20 { background: #ffc107; color: #2c3e50; }

        /* Back Button */
        .back-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            color: #f8f5e6;
        }

        /* Menu Modal */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .menu-overlay.active {
            display: flex;
        }

        .menu-modal {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-height: 90vh;
            overflow-y: auto;
        }

        .menu-header {
            background: linear-gradient(135deg, #1a3510 0%, #2d5016 100%);
            color: #f8f5e6;
            padding: 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .menu-header h2 {
            font-size: 20px;
            font-weight: 700;
        }

        .menu-close {
            background: none;
            border: none;
            color: #f8f5e6;
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
        }

        .menu-content {
            padding: 20px;
        }

        .menu-item {
            padding: 16px;
            border-bottom: 1px solid #e1e4e8;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: #f8f9fa;
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .menu-item-icon {
            font-size: 24px;
        }

        .menu-item-text {
            flex: 1;
        }

        .menu-item-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 2px;
        }

        .menu-item-subtitle {
            font-size: 13px;
            color: #6c757d;
        }

        .instruction-banner {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            font-size: 13px;
            color: #856404;
            font-weight: 500;
        }

        .tiles-display {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tile-divider {
            width: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            font-size: 16px;
        }

    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <button class="back-btn" id="backBtn" style="display: none;">←</button>
            <div class="logo" style="font-size: 18px; font-weight: 700; color: #f8f5e6; letter-spacing: 1px; cursor: pointer;" onclick="goToScreen('homeScreen')">
                FOURTH WALL MJ
            </div>
            <button class="menu-btn" onclick="toggleMenu()">☰</button>
        </div>
    </div>

    <div class="container">
        <!-- Home Screen -->
        <div class="screen active" id="homeScreen">
            <!-- Name Input -->
            <div id="nameInputSection" style="background: rgba(248, 245, 230, 0.95); border-radius: 12px; padding: 24px; margin-bottom: 20px; border: 2px solid rgba(212, 175, 55, 0.4); box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
                <div id="nameEntryForm">
                    <h3 style="font-size: 18px; margin-bottom: 12px; color: #2d5016; font-weight: 600;">👋🏽 WHO'S PLAYING?</h3>
                    <p style="font-size: 14px; color: #6c757d; margin-bottom: 16px;">FIRST NAME + LAST INITIAL</p>
                    <input 
                        type="text" 
                        id="playerName" 
                        placeholder="E.G. STEPHAN K"
                        style="width: 100%; padding: 14px; border: 2px solid #d4af37; border-radius: 8px; font-size: 16px; font-family: inherit; background: white; transition: all 0.3s; text-transform: uppercase;"
                        value=""
                    />
                </div>
                <div id="welcomeBackMessage" style="display: none; text-align: center;">
                    <h3 style="font-size: 22px; margin-bottom: 8px; color: #2d5016; font-weight: 700;">WELCOME BACK,</h3>
                    <div style="font-size: 28px; color: #d4af37; font-weight: 700; letter-spacing: 0.5px;" id="welcomeBackName"></div>
                </div>
                <div id="nameDisplay" style="display: none; margin-top: 12px; padding: 12px; background: rgba(45, 80, 22, 0.1); border-radius: 6px; color: #2d5016; font-weight: 600; border-left: 4px solid #2d5016;">
                    ✓ READY TO PLAY: <span id="currentPlayerName"></span>
                </div>
            </div>

            <div class="main-actions">
                <div class="action-card" onclick="goToCalculator()">
                    <div class="action-icon">🧮</div>
                    <div class="action-content">
                        <h2>FOURTH WALL CALCULATOR</h2>
                    </div>
                </div>

                <div class="action-card disabled">
                    <div class="action-icon">📊</div>
                    <div class="action-content">
                        <h2>IDENTIFY TILES</h2>
                        <p>COMING SOON</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Calculator Screen -->
        <div class="screen" id="calculatorScreen">
            <!-- STICKY Selected Tiles Display -->
            <div class="sticky-tile-counter">
                <h3>✓ YOUR TILES (<span id="tileCount">0</span>)</h3>
                <div class="selected-tiles-display" id="selectedTilesDisplay">
                    <div style="text-align: center; color: #6c757d; font-size: 13px;">SELECT TILES BELOW</div>
                </div>
                <button class="btn btn-secondary" onclick="clearAllTiles()" style="padding: 10px; font-size: 13px;">CLEAR ALL</button>
            </div>

            <!-- Characters -->
            <div class="tile-section">
                <h3>萬 CHARACTERS</h3>
                <div class="tile-grid" id="characterGrid"></div>
            </div>

            <!-- Bamboo -->
            <div class="tile-section">
                <h3>🎋 BAMBOO</h3>
                <div class="tile-grid" id="bambooGrid"></div>
            </div>

            <!-- Dots -->
            <div class="tile-section">
                <h3>🔵 DOTS</h3>
                <div class="tile-grid" id="dotGrid"></div>
            </div>

            <!-- Winds -->
            <div class="tile-section">
                <h3>🧭 WINDS</h3>
                <div class="tile-grid winds" id="windGrid"></div>
            </div>

            <!-- Dragons -->
            <div class="tile-section">
                <h3>🐉 DRAGONS</h3>
                <div class="tile-grid dragons" id="dragonGrid"></div>
            </div>

            <!-- Flowers -->
            <div class="tile-section">
                <h3>🌸 FLOWERS & SEASONS</h3>
                <div class="tile-grid flowers" id="flowerGrid"></div>
            </div>

            <!-- Seat Wind -->
            <div class="toggle-section">
                <h3>🧭 SEAT WIND</h3>
                <div class="toggle-grid">
                    <div class="toggle-option selected" onclick="selectToggle(this, 'seatWind', 'east')">
                        <div class="label">東 EAST</div>
                        <div class="sublabel">DEALER</div>
                    </div>
                    <div class="toggle-option" onclick="selectToggle(this, 'seatWind', 'south')">
                        <div class="label">南 SOUTH</div>
                    </div>
                    <div class="toggle-option" onclick="selectToggle(this, 'seatWind', 'west')">
                        <div class="label">西 WEST</div>
                    </div>
                    <div class="toggle-option" onclick="selectToggle(this, 'seatWind', 'north')">
                        <div class="label">北 NORTH</div>
                    </div>
                </div>
            </div>

            <!-- Round Wind -->
            <div class="toggle-section">
                <h3>🌬️ ROUND WIND</h3>
                <div class="toggle-grid">
                    <div class="toggle-option selected" onclick="selectToggle(this, 'roundWind', 'east')">
                        <div class="label">東 EAST</div>
                    </div>
                    <div class="toggle-option" onclick="selectToggle(this, 'roundWind', 'south')">
                        <div class="label">南 SOUTH</div>
                    </div>
                    <div class="toggle-option" onclick="selectToggle(this, 'roundWind', 'west')">
                        <div class="label">西 WEST</div>
                    </div>
                    <div class="toggle-option" onclick="selectToggle(this, 'roundWind', 'north')">
                        <div class="label">北 NORTH</div>
                    </div>
                </div>
            </div>

            <!-- Win Conditions -->
            <div class="toggle-section">
                <h3>🎯 ADDITIONAL POINTS</h3>
                <div class="toggle-grid single">
                    <div class="toggle-option" onclick="toggleSpecial(this, 'selfDraw')">
                        <div class="label">SELF DRAW (+1 PT)</div>
                    </div>
                    <div class="toggle-option" onclick="toggleSpecial(this, 'concealed')">
                        <div class="label">CONCEALED HAND (+1 PT)</div>
                    </div>
                    <div class="toggle-option" onclick="toggleSpecial(this, 'robbedKong')">
                        <div class="label">ROBBING THE KONG (+1 PT)</div>
                    </div>
                    <div class="toggle-option" onclick="toggleSpecial(this, 'lastTile')">
                        <div class="label">LAST TILE (+1 PT)</div>
                    </div>
                    <div class="toggle-option" onclick="toggleSpecial(this, 'kongFlowerReplacement')">
                        <div class="label">KONG/FLOWER REPLACEMENT (+2 PT)</div>
                    </div>
                    <div class="toggle-option" onclick="toggleSpecial(this, 'blessingHeaven')">
                        <div class="label">WIN ON DRAW - DEALER (+13 PT)</div>
                    </div>
                    <div class="toggle-option" onclick="toggleSpecial(this, 'blessingEarth')">
                        <div class="label">WIN ON FIRST DISCARD (+13 PT)</div>
                    </div>
                </div>
            </div>

            <button class="btn btn-primary" onclick="calculateScore()" id="calculateBtn" style="font-size: 18px; padding: 18px;">
                CALCULATE SCORE
            </button>
        </div>

        <!-- Results Screen -->
        <div class="screen" id="resultsScreen">
            <!-- Compact Hero -->
            <div class="result-hero" style="padding: 16px; margin-bottom: 8px;">
                <div id="victoryPhrase" style="display: none; font-size: 14px; font-weight: 600; color: #d4af37; margin-bottom: 6px; letter-spacing: 1px;">
                    食糊 • SIK WU
                </div>
                
                <!-- NAME -->
                <div style="font-size: 22px; font-weight: 700; margin-bottom: 12px; color: #2d5016; letter-spacing: 0.5px; text-transform: uppercase;" id="winnerName">PLAYER</div>
                
                <!-- FAAN and PAYOUT in two columns -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 12px;">
                    <!-- FAAN -->
                    <div style="text-align: center;">
                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: #2d5016; opacity: 0.8;">FAAN</div>
                        <div style="font-size: 48px; color: #2d5016; font-weight: 700; line-height: 1;"><span id="totalPoints">0</span></div>
                    </div>
                    
                    <!-- PAYOUT -->
                    <div style="text-align: center;">
                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: #2d5016; opacity: 0.8;">PAYOUT</div>
                        <div style="font-size: 48px; color: #2d5016; font-weight: 700; line-height: 1;"><span id="payoutAmount">0</span></div>
                    </div>
                </div>
                
                <!-- Colored coins with simple label -->
                <div style="margin-bottom: 8px;">
                    <div class="payout" id="payoutCoins" style="gap: 6px; font-size: 28px; margin-bottom: 6px; justify-content: center; display: flex; flex-wrap: wrap;"></div>
                    <div style="font-size: 11px; color: #2d5016; font-weight: 600; text-transform: uppercase;" id="payoutDescription">PER PLAYER</div>
                </div>

                <div style="font-size: 10px; opacity: 0.7; margin-top: 2px; color: #2d5016; text-transform: uppercase;" id="winTypeLabel">DEALER / SELF DRAW</div>
            </div>

            <!-- Ultra Compact Hand Display -->
            <div style="margin-bottom: 8px; background: rgba(248, 245, 230, 0.95); padding: 10px; border-radius: 8px; border: 2px solid rgba(212, 175, 55, 0.3);">
                <h3 style="font-size: 12px; margin-bottom: 6px; color: #2d5016; font-weight: 700; text-transform: uppercase;">🀄 YOUR HAND</h3>
                <div class="tiles-display" style="justify-content: center; gap: 3px;" id="resultsTilesDisplay">
                    <!-- Tiles will be populated -->
                </div>
            </div>

            <!-- Ultra Compact Breakdown -->
            <div style="background: rgba(248, 245, 230, 0.95); border-radius: 8px; padding: 10px; margin-bottom: 8px; border: 2px solid rgba(212, 175, 55, 0.3);">
                <h3 style="color: #2d5016; font-weight: 700; letter-spacing: 0.5px; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">📊 BREAKDOWN</h3>
                <div id="breakdownItems" style="font-size: 12px;">
                    <!-- Breakdown items -->
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0 0; margin-top: 6px; border-top: 2px solid #d4af37; font-weight: 700; font-size: 14px; color: #2d5016;">
                    <div>TOTAL</div>
                    <div><span id="totalPointsBreakdown">0</span> PT</div>
                </div>
            </div>

            <!-- Compact Buttons -->
            <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 8px;">
                <button class="btn btn-secondary" onclick="backToCalculator()" style="padding: 12px; font-size: 14px;">BACK</button>
                <button class="btn btn-primary" onclick="resetAndScore()" style="padding: 12px; font-size: 14px;">NEW HAND</button>
            </div>
        </div>

        <!-- History Screen -->
        <div class="screen" id="historyScreen">
            <!-- Summary Stats -->
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 20px;">
                <div style="background: linear-gradient(135deg, rgba(248, 245, 230, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%); border: 2px solid rgba(212, 175, 55, 0.4); border-radius: 12px; padding: 16px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: #2d5016; margin-bottom: 4px;" id="totalWins">0</div>
                    <div style="font-size: 11px; color: #6c757d; text-transform: uppercase;">WINS</div>
                </div>
                <div style="background: linear-gradient(135deg, rgba(248, 245, 230, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%); border: 2px solid rgba(212, 175, 55, 0.4); border-radius: 12px; padding: 16px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: #d4af37; margin-bottom: 4px;" id="highestScore">0</div>
                    <div style="font-size: 11px; color: #6c757d; text-transform: uppercase;">HIGH SCORE</div>
                </div>
                <div style="background: linear-gradient(135deg, rgba(248, 245, 230, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%); border: 2px solid rgba(212, 175, 55, 0.4); border-radius: 12px; padding: 16px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: #769656; margin-bottom: 4px;" id="totalCoins">0</div>
                    <div style="font-size: 11px; color: #6c757d; text-transform: uppercase;">TOTAL COINS</div>
                </div>
            </div>

            <!-- Sort Options -->
            <div style="background: white; border-radius: 8px; padding: 12px; margin-bottom: 16px; display: flex; gap: 8px; align-items: center;">
                <div style="font-size: 13px; font-weight: 600; color: #2c3e50;">SORT:</div>
                <button class="btn" onclick="sortHistory('newest')" id="sortNewest" style="padding: 8px 16px; font-size: 13px; background: #769656; color: white; width: auto;">NEWEST</button>
                <button class="btn" onclick="sortHistory('highest')" id="sortHighest" style="padding: 8px 16px; font-size: 13px; background: #f8f9fa; color: #6c757d; border: 2px solid #e1e4e8; width: auto;">HIGHEST</button>
            </div>

            <!-- History List -->
            <div id="historyList"></div>

            <!-- Empty State -->
            <div id="historyEmpty" style="display: none; text-align: center; padding: 60px 20px; color: #6c757d;">
                <div style="font-size: 64px; margin-bottom: 16px;">🀄</div>
                <h3 style="font-size: 18px; margin-bottom: 8px; color: #2c3e50;">NO WINS YET</h3>
                <p style="font-size: 14px;">YOUR WINNING HANDS WILL APPEAR HERE</p>
            </div>
        </div>
    </div>

    <!-- Menu Modal -->
    <div class="menu-overlay" id="menuOverlay" onclick="closeMenuIfOutside(event)">
        <div class="menu-modal" onclick="event.stopPropagation()">
            <div class="menu-header">
                <h2>MENU</h2>
                <button class="menu-close" onclick="toggleMenu()">×</button>
            </div>
            <div class="menu-content">
                <div class="menu-item" onclick="goToHistory()">
                    <div class="menu-item-icon">📊</div>
                    <div class="menu-item-text">
                        <div class="menu-item-title">SCORE HISTORY</div>
                        <div class="menu-item-subtitle">View your winning hands</div>
                    </div>
                </div>
                <div class="menu-item" onclick="changeName()">
                    <div class="menu-item-icon">✏️</div>
                    <div class="menu-item-text">
                        <div class="menu-item-title">CHANGE NAME</div>
                        <div class="menu-item-subtitle">Update your player name</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // All possible tiles
        const allTiles = {
            character: ['1萬', '2萬', '3萬', '4萬', '5萬', '6萬', '7萬', '8萬', '9萬'],
            bamboo: ['1🎋', '2🎋', '3🎋', '4🎋', '5🎋', '6🎋', '7🎋', '8🎋', '9🎋'],
            dot: ['1🔵', '2🔵', '3🔵', '4🔵', '5🔵', '6🔵', '7🔵', '8🔵', '9🔵'],
            wind: ['東', '南', '西', '北'],
            dragon: ['中', '發', '白'],
            flower: ['🪻', '🌸', '🌼', '🎋', '🌱', '☀️', '🍂', '❄️']
        };

        const flowerLabels = ['F1', 'F2', 'F3', 'F4', 'S1', 'S2', 'S3', 'S4'];

        // State
        let gameState = {
            selectedTiles: [], 
            selectedFlowers: [],
            seatWind: 'east',
            roundWind: 'east',
            winConditions: [],
            playerName: '',
            history: []
        };

        // Scoring rules
        const scoringRules = {
            'allChow': { points: 1, name: 'All Chow', description: 'Every set is a sequence' },
            'dragonPong': { points: 1, name: 'Dragon Pong', description: 'Pong/Kong of any dragon' },
            'roundWind': { points: 1, name: 'Round Wind', description: 'Pong/Kong of the current wind' },
            'seatWind': { points: 1, name: 'Seat Wind', description: "Pong/Kong of the player's wind" },
            'selfDraw': { points: 1, name: 'Self Draw', description: 'Winning by drawing a tile' },
            'concealed': { points: 1, name: 'Concealed Hand', description: 'No melds shown' },
            'robbedKong': { points: 1, name: 'Robbing the Kong', description: "Won off another player's kong" },
            'lastTile': { points: 1, name: 'Last Tile', description: 'Last tile in game' },
            'selfFlower': { points: 1, name: 'Self Flower', description: 'Either flower of your seat' },
            'noFlowers': { points: 1, name: 'No Flowers', description: 'Having no flowers' },
            'flowerSet': { points: 2, name: 'Flower Set', description: 'Full set of flowers of same color' },
            'kongFlowerReplacement': { points: 2, name: 'Kong/Flower Replacement', description: 'Won from replacement tile' },
            'allPongs': { points: 3, name: 'All Pongs', description: 'All triplets/kongs' },
            'mixedOneSuit': { points: 3, name: 'Mixed One Suit', description: 'Honor tiles + one suit' },
            'sevenPairs': { points: 4, name: 'All Pairs', description: '7 unique pairs' },
            'minorDragons': { points: 5, name: 'Minor Dragons', description: '2 dragon pongs + pair of 3rd' },
            'minorWinds': { points: 6, name: 'Minor Winds', description: '3 winds + pair of 4th' },
            'pureOneSuit': { points: 7, name: 'Pure One Suit', description: 'All tiles from single suit' },
            'allFlowers': { points: 8, name: 'All Flowers', description: 'All 8 flowers' },
            'greatDragons': { points: 8, name: 'Great Dragons', description: 'All 3 dragons' },
            'allHonors': { points: 10, name: 'All Honors', description: 'All honor tiles' },
            'selfTriplets': { points: 10, name: 'Self Triplets', description: '4 concealed pongs' },
            'orphans': { points: 10, name: 'Orphans', description: 'Pongs/Kongs of 1s and 9s only' },
            'nineGates': { points: 10, name: '9 Gates', description: '1112345678999 in one suit' },
            'greatWinds': { points: 13, name: 'Great Winds', description: 'All 4 winds' },
            'thirteenOrphans': { points: 13, name: 'Thirteen Orphans', description: 'One of each terminal and honor' },
            'bambooForest': { points: 13, name: 'Bamboo Forest', description: 'All green tiles' },
            'allKongs': { points: 13, name: 'All Kongs', description: '4 Kongs' },
            'blessingHeaven': { points: 13, name: 'Blessing of Heaven', description: 'Dealer wins with starting hand' },
            'blessingEarth': { points: 13, name: 'Blessing of Earth', description: 'Won on first discard' }
        };

        // Payout table
        const payoutTable = {
            1: { nonDealerDiscard: 1, dealerDiscard: 2, nonDealerSelf: 1, dealerSelf: 1 },
            2: { nonDealerDiscard: 2, dealerDiscard: 3, nonDealerSelf: 2, dealerSelf: 2 },
            3: { nonDealerDiscard: 4, dealerDiscard: 6, nonDealerSelf: 3, dealerSelf: 5 },
            4: { nonDealerDiscard: 8, dealerDiscard: 12, nonDealerSelf: 6, dealerSelf: 9 },
            5: { nonDealerDiscard: 16, dealerDiscard: 24, nonDealerSelf: 12, dealerSelf: 18 },
            6: { nonDealerDiscard: 32, dealerDiscard: 48, nonDealerSelf: 24, dealerSelf: 36 },
            7: { nonDealerDiscard: 40, dealerDiscard: 60, nonDealerSelf: 30, dealerSelf: 45 },
            8: { nonDealerDiscard: 50, dealerDiscard: 70, nonDealerSelf: 35, dealerSelf: 50 },
            9: { nonDealerDiscard: 60, dealerDiscard: 80, nonDealerSelf: 40, dealerSelf: 55 },
            10: { nonDealerDiscard: 70, dealerDiscard: 100, nonDealerSelf: 45, dealerSelf: 70 },
            11: { nonDealerDiscard: 80, dealerDiscard: 110, nonDealerSelf: 50, dealerSelf: 75 },
            12: { nonDealerDiscard: 90, dealerDiscard: 120, nonDealerSelf: 55, dealerSelf: 80 },
            13: { nonDealerDiscard: 100, dealerDiscard: 140, nonDealerSelf: 60, dealerSelf: 90 }
        };

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            const savedName = localStorage.getItem('fourthWallPlayerName');
            if (savedName) {
                gameState.playerName = savedName;
                showWelcomeBack(savedName);
            }

            const savedHistory = localStorage.getItem('fourthWallHistory');
            if (savedHistory) {
                try {
                    gameState.history = JSON.parse(savedHistory);
                } catch (e) {
                    console.error('Error loading history:', e);
                    gameState.history = [];
                }
            }

            document.getElementById('playerName').addEventListener('change', (e) => {
                const name = e.target.value.trim();
                if (name) {
                    gameState.playerName = name;
                    localStorage.setItem('fourthWallPlayerName', name);
                    showNameConfirmation(name);
                }
            });

            initializeTileGrids();
        });

        function showWelcomeBack(name) {
            const firstName = name.split(/[\s.]/)[0];
            document.getElementById('nameEntryForm').style.display = 'none';
            document.getElementById('welcomeBackMessage').style.display = 'block';
            document.getElementById('welcomeBackName').textContent = firstName.toUpperCase();
        }

        function showNameConfirmation(name) {
            document.getElementById('nameDisplay').style.display = 'block';
            document.getElementById('currentPlayerName').textContent = name;
        }

        let currentScreen = 'homeScreen';

        function goToScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
            currentScreen = screenId;
            const backBtn = document.getElementById('backBtn');
            backBtn.style.display = screenId === 'homeScreen' ? 'none' : 'block';
        }

        document.getElementById('backBtn').addEventListener('click', () => {
            goToScreen('homeScreen');
        });

        function goToCalculator() {
            if (!gameState.playerName) {
                alert('PLEASE ENTER NAME FIRST 🙏🏽');
                document.getElementById('playerName').focus();
                return;
            }
            resetCalculator();
            goToScreen('calculatorScreen');
        }

        function resetCalculator() {
            gameState.selectedTiles = [];
            gameState.selectedFlowers = [];
            gameState.winConditions = [];
            updateTileDisplay();
        }

        function initializeTileGrids() {
            createTileGrid('characterGrid', allTiles.character, 'character');
            createTileGrid('bambooGrid', allTiles.bamboo, 'bamboo');
            createTileGrid('dotGrid', allTiles.dot, 'dot');
            createTileGrid('windGrid', allTiles.wind, 'wind');
            createTileGrid('dragonGrid', allTiles.dragon, 'dragon');
            createFlowerGrid();
        }

        function createTileGrid(containerId, tiles, suit) {
            const container = document.getElementById(containerId);
            container.innerHTML = tiles.map(tile => {
                return `
                    <div class="tile-option ${suit}" onclick="toggleTile('${tile.replace(/'/g, "\\'")}', '${suit}')" data-tile="${tile}">
                        ${tile}
                        <div class="tile-count zero">0</div>
                    </div>
                `;
            }).join('');
        }

        function createFlowerGrid() {
            const container = document.getElementById('flowerGrid');
            container.innerHTML = allTiles.flower.map((flower, idx) => {
                return `
                    <div class="tile-option" onclick="toggleFlowerTile(${idx})" data-flower="${idx}">
                        <div style="font-size: 20px;">${flower}</div>
                        <div style="font-size: 11px; margin-top: 4px; opacity: 0.7;">${flowerLabels[idx]}</div>
                    </div>
                `;
            }).join('');
        }

        function toggleTile(tile, suit) {
            const count = gameState.selectedTiles.filter(t => t.tile === tile).length;
            
            if (count < 4) {
                gameState.selectedTiles.push({ tile, suit });
            } else {
                gameState.selectedTiles = gameState.selectedTiles.filter(t => t.tile !== tile);
            }

            updateTileDisplay();
        }

        function toggleFlowerTile(idx) {
            const index = gameState.selectedFlowers.indexOf(idx);
            if (index > -1) {
                gameState.selectedFlowers.splice(index, 1);
            } else {
                gameState.selectedFlowers.push(idx);
            }
            updateTileDisplay();
        }

        function updateTileDisplay() {
            document.querySelectorAll('.tile-option[data-tile]').forEach(el => {
                const tile = el.getAttribute('data-tile');
                const count = gameState.selectedTiles.filter(t => t.tile === tile).length;
                const countEl = el.querySelector('.tile-count');
                countEl.textContent = count;
                countEl.classList.toggle('zero', count === 0);
                el.classList.toggle('selected', count > 0);
                el.classList.toggle('disabled', count >= 4);
            });

            document.querySelectorAll('.tile-option[data-flower]').forEach(el => {
                const flowerIdx = parseInt(el.getAttribute('data-flower'));
                el.classList.toggle('selected', gameState.selectedFlowers.includes(flowerIdx));
            });

            const display = document.getElementById('selectedTilesDisplay');
            const totalCount = gameState.selectedTiles.length;
            document.getElementById('tileCount').textContent = totalCount;

            if (totalCount === 0 && gameState.selectedFlowers.length === 0) {
                display.innerHTML = '<div style="text-align: center; color: #6c757d; font-size: 13px;">SELECT TILES BELOW</div>';
                return;
            }

            let html = '';
            gameState.selectedTiles.forEach(tileObj => {
                html += `<div class="selected-tile ${tileObj.suit}">${tileObj.tile}</div>`;
            });

            gameState.selectedFlowers.forEach(idx => {
                html += `<div class="selected-tile flower">${allTiles.flower[idx]}</div>`;
            });

            display.innerHTML = html;
        }

        function clearAllTiles() {
            gameState.selectedTiles = [];
            gameState.selectedFlowers = [];
            updateTileDisplay();
        }

        function selectToggle(element, group, value) {
            element.parentElement.querySelectorAll('.toggle-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            element.classList.add('selected');
            gameState[group] = value;
        }

        function toggleSpecial(element, condition) {
            element.classList.toggle('selected');
            if (element.classList.contains('selected')) {
                if (!gameState.winConditions.includes(condition)) {
                    gameState.winConditions.push(condition);
                }
            } else {
                gameState.winConditions = gameState.winConditions.filter(c => c !== condition);
            }
        }

        function calculateScore() {
            const totalCount = gameState.selectedTiles.length;
            
            if (totalCount < 13) {
                alert('⚠️ NOT ENOUGH TILES\n\nYou need at least 13-14 tiles to form a winning hand!\n\nCurrent count: ' + totalCount);
                return;
            }

            const tiles = gameState.selectedTiles;

            // COMPREHENSIVE VALIDATION WITH ALL SPECIAL HANDS
            const bestHand = findBestHandComplete(tiles);
            
            if (!bestHand) {
                alert('⚠️ INVALID HAND\n\nCANNOT FORM A VALID WINNING COMBINATION WITH THESE TILES.\n\nA WINNING HAND NEEDS:\n• 4 SETS (CHOWS/PONGS/KONGS) + 1 PAIR\nOR\n• 7 PAIRS (FOR SEVEN PAIRS)\nOR\n• SPECIAL HANDS (13 ORPHANS, 9 GATES, ALL KONGS, ETC.)');
                return;
            }

            let totalPoints = 0;
            let breakdown = [];

            // Add pattern points
            bestHand.patterns.forEach(pattern => {
                if (scoringRules[pattern]) {
                    breakdown.push({
                        name: scoringRules[pattern].name,
                        detail: scoringRules[pattern].description,
                        points: scoringRules[pattern].points
                    });
                    totalPoints += scoringRules[pattern].points;
                }
            });

            // Check for Seat Wind and Round Wind pongs/kongs
            if (!bestHand.specialHand) {  // Only for standard hands
                const seatWindMap = { 'east': '東', 'south': '南', 'west': '西', 'north': '北' };
                const roundWindMap = { 'east': '東', 'south': '南', 'west': '西', 'north': '北' };
                
                const seatWindTile = seatWindMap[gameState.seatWind];
                const roundWindTile = roundWindMap[gameState.roundWind];
                
                // Check for seat wind pong/kong
                const hasSeatWindMeld = bestHand.melds.some(meld => 
                    (meld.type === 'pong' || meld.type === 'kong') && 
                    meld.tiles[0] === seatWindTile
                );
                
                if (hasSeatWindMeld) {
                    breakdown.push({
                        name: scoringRules.seatWind.name,
                        detail: `${seatWindTile} ${gameState.seatWind.toUpperCase()}`,
                        points: scoringRules.seatWind.points
                    });
                    totalPoints += scoringRules.seatWind.points;
                }
                
                // Check for round wind pong/kong
                const hasRoundWindMeld = bestHand.melds.some(meld => 
                    (meld.type === 'pong' || meld.type === 'kong') && 
                    meld.tiles[0] === roundWindTile
                );
                
                if (hasRoundWindMeld) {
                    breakdown.push({
                        name: scoringRules.roundWind.name,
                        detail: `${roundWindTile} ${gameState.roundWind.toUpperCase()} ROUND`,
                        points: scoringRules.roundWind.points
                    });
                    totalPoints += scoringRules.roundWind.points;
                }
                
                // Check for dragon pongs/kongs
                const dragonMelds = bestHand.melds.filter(meld => 
                    (meld.type === 'pong' || meld.type === 'kong') && 
                    meld.suit === 'dragon'
                );
                
                dragonMelds.forEach(meld => {
                    // Only add dragon pong if not already counted in patterns (like Great Dragons)
                    const hasGreatDragons = bestHand.patterns.includes('greatDragons');
                    if (!hasGreatDragons) {
                        breakdown.push({
                            name: scoringRules.dragonPong.name,
                            detail: meld.tiles[0],
                            points: scoringRules.dragonPong.points
                        });
                        totalPoints += scoringRules.dragonPong.points;
                    }
                });
            }

            // Win conditions
            gameState.winConditions.forEach(condition => {
                if (scoringRules[condition]) {
                    breakdown.push({
                        name: scoringRules[condition].name,
                        detail: scoringRules[condition].description,
                        points: scoringRules[condition].points
                    });
                    totalPoints += scoringRules[condition].points;
                }
            });

            // Flowers
            const flowerCount = gameState.selectedFlowers.length;
            if (flowerCount === 0) {
                breakdown.push({
                    name: scoringRules.noFlowers.name,
                    detail: '',
                    points: scoringRules.noFlowers.points
                });
                totalPoints += scoringRules.noFlowers.points;
            } else if (flowerCount === 8) {
                breakdown.push({
                    name: scoringRules.allFlowers.name,
                    detail: '',
                    points: scoringRules.allFlowers.points
                });
                totalPoints += scoringRules.allFlowers.points;
            } else {
                const flowers = gameState.selectedFlowers.filter(f => f < 4);
                const seasons = gameState.selectedFlowers.filter(f => f >= 4);
                
                if (flowers.length === 4) {
                    breakdown.push({ name: 'Flower Set', detail: 'All 4 flowers', points: 2 });
                    totalPoints += 2;
                }
                if (seasons.length === 4) {
                    breakdown.push({ name: 'Season Set', detail: 'All 4 seasons', points: 2 });
                    totalPoints += 2;
                }
                
                const seatFlowerMap = { 'east': [0, 4], 'south': [1, 5], 'west': [2, 6], 'north': [3, 7] };
                const selfFlowers = seatFlowerMap[gameState.seatWind].filter(f => gameState.selectedFlowers.includes(f));
                if (selfFlowers.length > 0) {
                    breakdown.push({
                        name: 'Self Flower',
                        detail: selfFlowers.map(f => flowerLabels[f]).join(', '),
                        points: selfFlowers.length
                    });
                    totalPoints += selfFlowers.length;
                }
            }

            if (totalPoints < 3) {
                alert('⚠️ INVALID HAND\n\nTHIS HAND SCORES ' + totalPoints + ' POINT(S).\nYOU NEED AT LEAST 3 POINTS TO WIN.\n\nPLEASE CHECK:\n• HAND PATTERNS\n• ADDITIONAL WIN CONDITIONS\n• FLOWERS AND SEAT BONUSES');
                return;
            }

            const isDealer = gameState.seatWind === 'east';
            const isSelfDraw = gameState.winConditions.includes('selfDraw');
            const payout = calculatePayout(totalPoints, isDealer, isSelfDraw);

            saveToHistory(totalPoints, payout, breakdown, isDealer, isSelfDraw, bestHand);
            updateResultsScreen(totalPoints, payout, breakdown, isDealer, isSelfDraw, bestHand);
            goToScreen('resultsScreen');
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // ===== COMPLETE HAND VALIDATION WITH ALL SPECIAL HANDS =====
        function findBestHandComplete(tiles) {
            // Priority 1: Check special 13-point hands first
            const thirteenOrphans = checkThirteenOrphans(tiles);
            if (thirteenOrphans) return thirteenOrphans;

            const bambooForest = checkBambooForest(tiles);
            if (bambooForest) return bambooForest;

            const allKongs = checkAllKongs(tiles);
            if (allKongs) return allKongs;

            // Priority 2: Check 10-point special hands
            const nineGates = checkNineGates(tiles);
            if (nineGates) return nineGates;

            // Priority 3: Check seven pairs
            const sevenPairs = checkSevenPairs(tiles);
            if (sevenPairs) return sevenPairs;

            // Priority 4: Try standard 4 melds + 1 pair with multiple strategies
            const tileCounts = {};
            tiles.forEach(t => {
                if (!tileCounts[t.tile]) tileCounts[t.tile] = { count: 0, suit: t.suit };
                tileCounts[t.tile].count++;
            });

            // Try each possible pair position
            for (let [pairTile, pairData] of Object.entries(tileCounts)) {
                if (pairData.count >= 2) {
                    const testCounts = JSON.parse(JSON.stringify(tileCounts));
                    testCounts[pairTile].count -= 2;
                    
                    // Strategy A: Pongs first, then chows
                    const handA = tryFormMelds(testCounts, true);
                    if (handA && handA.length === 4) {
                        return addPatterns({
                            melds: handA,
                            pair: { tiles: [pairTile, pairTile], suit: pairData.suit },
                            patterns: []
                        });
                    }
                    
                    // Strategy B: Chows first, then pongs
                    const handB = tryFormMelds(testCounts, false);
                    if (handB && handB.length === 4) {
                        return addPatterns({
                            melds: handB,
                            pair: { tiles: [pairTile, pairTile], suit: pairData.suit },
                            patterns: []
                        });
                    }
                    
                    // Strategy C: Mixed approach
                    const handC = tryFormMeldsMixed(testCounts);
                    if (handC && handC.length === 4) {
                        return addPatterns({
                            melds: handC,
                            pair: { tiles: [pairTile, pairTile], suit: pairData.suit },
                            patterns: []
                        });
                    }
                }
            }
            
            return null;
        }

        // THIRTEEN ORPHANS: One of each 1, 9, wind, dragon + 1 pair
        function checkThirteenOrphans(tiles) {
            if (tiles.length !== 14) return null;
            
            const required = [
                '1萬', '9萬', '1🎋', '9🎋', '1🔵', '9🔵',  // Terminals
                '東', '南', '西', '北',  // Winds
                '中', '發', '白'  // Dragons
            ];
            
            const tileCounts = {};
            tiles.forEach(t => {
                tileCounts[t.tile] = (tileCounts[t.tile] || 0) + 1;
            });
            
            // Check if we have exactly one of each required tile, plus one extra
            let pairTile = null;
            for (const tile of required) {
                const count = tileCounts[tile] || 0;
                if (count === 0) return null;  // Missing required tile
                if (count === 2 && pairTile === null) {
                    pairTile = tile;
                } else if (count > 1) {
                    return null;  // Too many of a tile
                }
            }
            
            // Must have exactly 13 unique types and 1 pair
            if (Object.keys(tileCounts).length !== 13 || !pairTile) return null;
            
            return {
                melds: [],
                pair: null,
                patterns: ['thirteenOrphans'],
                specialHand: true
            };
        }

        // BAMBOO FOREST: All green tiles (2,3,4,6,8 Bamboo + Green Dragon)
        function checkBambooForest(tiles) {
            const greenTiles = ['2🎋', '3🎋', '4🎋', '6🎋', '8🎋', '發'];
            
            for (const t of tiles) {
                if (!greenTiles.includes(t.tile)) return null;
            }
            
            // Valid bamboo forest, try to form standard hand
            const tileCounts = {};
            tiles.forEach(t => {
                if (!tileCounts[t.tile]) tileCounts[t.tile] = { count: 0, suit: t.suit };
                tileCounts[t.tile].count++;
            });

            for (let [pairTile, pairData] of Object.entries(tileCounts)) {
                if (pairData.count >= 2) {
                    const testCounts = JSON.parse(JSON.stringify(tileCounts));
                    testCounts[pairTile].count -= 2;
                    
                    const melds = tryFormMelds(testCounts, true);
                    if (melds && melds.length === 4) {
                        return {
                            melds: melds,
                            pair: { tiles: [pairTile, pairTile], suit: pairData.suit },
                            patterns: ['bambooForest']
                        };
                    }
                }
            }
            
            return null;
        }

        // ALL KONGS: Four kongs (16 tiles total)
        function checkAllKongs(tiles) {
            if (tiles.length !== 18) return null;  // 4 kongs (16) + 1 pair (2)
            
            const tileCounts = {};
            tiles.forEach(t => {
                if (!tileCounts[t.tile]) tileCounts[t.tile] = { count: 0, suit: t.suit };
                tileCounts[t.tile].count++;
            });
            
            const kongs = [];
            let pair = null;
            
            for (let [tile, data] of Object.entries(tileCounts)) {
                if (data.count === 4) {
                    kongs.push({ type: 'kong', tiles: [tile, tile, tile, tile], suit: data.suit });
                } else if (data.count === 2 && !pair) {
                    pair = { tiles: [tile, tile], suit: data.suit };
                } else {
                    return null;  // Invalid count
                }
            }
            
            if (kongs.length === 4 && pair) {
                return {
                    melds: kongs,
                    pair: pair,
                    patterns: ['allKongs']
                };
            }
            
            return null;
        }

        // NINE GATES: 1112345678999 in single suit + 1 extra tile (MUST BE CONCEALED)
        function checkNineGates(tiles) {
            if (tiles.length !== 14) return null;
            
            // CRITICAL: Nine Gates only valid if concealed hand is selected
            if (!gameState.winConditions.includes('concealed')) return null;
            
            const suits = ['character', 'bamboo', 'dot'];
            
            for (const suit of suits) {
                const suitTiles = tiles.filter(t => t.suit === suit);
                if (suitTiles.length !== 14) continue;  // Must be pure suit
                
                const counts = {};
                suitTiles.forEach(t => {
                    const num = parseInt(t.tile.match(/\d+/)[0]);
                    counts[num] = (counts[num] || 0) + 1;
                });
                
                // Check pattern: 1(3+), 2(1+), 3(1+), 4(1+), 5(1+), 6(1+), 7(1+), 8(1+), 9(3+)
                const pattern = [
                    counts[1] >= 3,
                    counts[2] >= 1,
                    counts[3] >= 1,
                    counts[4] >= 1,
                    counts[5] >= 1,
                    counts[6] >= 1,
                    counts[7] >= 1,
                    counts[8] >= 1,
                    counts[9] >= 3
                ];
                
                if (pattern.every(p => p)) {
                    // Valid nine gates - must be concealed
                    return {
                        melds: [],
                        pair: null,
                        patterns: ['nineGates'],
                        specialHand: true
                    };
                }
            }
            
            return null;
        }

        function checkSevenPairs(tiles) {
            if (tiles.length !== 14) return null;
            
            const tileCounts = {};
            tiles.forEach(t => {
                if (!tileCounts[t.tile]) tileCounts[t.tile] = { count: 0, suit: t.suit };
                tileCounts[t.tile].count++;
            });

            const pairs = Object.entries(tileCounts).filter(([_, data]) => data.count === 2);
            if (pairs.length === 7) {
                const hand = { melds: [], pair: null, patterns: ['sevenPairs'] };
                pairs.forEach(([tile, data]) => {
                    hand.melds.push({ type: 'pair', tiles: [tile, tile], suit: data.suit });
                });
                return hand;
            }
            return null;
        }

        function tryFormMelds(tileCounts, pongsFirst) {
            const remaining = JSON.parse(JSON.stringify(tileCounts));
            const melds = [];

            if (pongsFirst) {
                for (let [tile, data] of Object.entries(remaining)) {
                    while (data.count >= 4 && melds.length < 4) {
                        melds.push({ type: 'kong', tiles: [tile, tile, tile, tile], suit: data.suit });
                        data.count -= 4;
                    }
                    while (data.count >= 3 && melds.length < 4) {
                        melds.push({ type: 'pong', tiles: [tile, tile, tile], suit: data.suit });
                        data.count -= 3;
                    }
                }
                while (melds.length < 4) {
                    const chow = findChow(remaining);
                    if (!chow) break;
                    melds.push(chow);
                }
            } else {
                while (melds.length < 4) {
                    const chow = findChow(remaining);
                    if (!chow) break;
                    melds.push(chow);
                }
                for (let [tile, data] of Object.entries(remaining)) {
                    while (data.count >= 4 && melds.length < 4) {
                        melds.push({ type: 'kong', tiles: [tile, tile, tile, tile], suit: data.suit });
                        data.count -= 4;
                    }
                    while (data.count >= 3 && melds.length < 4) {
                        melds.push({ type: 'pong', tiles: [tile, tile, tile], suit: data.suit });
                        data.count -= 3;
                    }
                }
            }

            return melds.length === 4 ? melds : null;
        }

        function tryFormMeldsMixed(tileCounts) {
            const remaining = JSON.parse(JSON.stringify(tileCounts));
            const melds = [];

            while (melds.length < 4) {
                let foundPong = false;
                for (let [tile, data] of Object.entries(remaining)) {
                    if (data.count >= 3) {
                        melds.push({ type: 'pong', tiles: [tile, tile, tile], suit: data.suit });
                        data.count -= 3;
                        foundPong = true;
                        break;
                    }
                }
                
                if (!foundPong) {
                    const chow = findChow(remaining);
                    if (!chow) break;
                    melds.push(chow);
                }
            }

            return melds.length === 4 ? melds : null;
        }

        function findChow(remaining) {
            for (let suit of ['character', 'bamboo', 'dot']) {
                const suitTiles = Object.entries(remaining)
                    .filter(([_, data]) => data.suit === suit && data.count > 0)
                    .sort((a, b) => {
                        const numA = parseInt(a[0].match(/\d+/)?.[0] || 0);
                        const numB = parseInt(b[0].match(/\d+/)?.[0] || 0);
                        return numA - numB;
                    });
                
                for (let [tile, data] of suitTiles) {
                    const match = tile.match(/(\d+)(.+)/);
                    if (!match) continue;
                    const num = parseInt(match[1]);
                    const suffix = match[2];
                    
                    if (num <= 7) {
                        const tile2 = `${num + 1}${suffix}`;
                        const tile3 = `${num + 2}${suffix}`;
                        if (remaining[tile2]?.count > 0 && remaining[tile3]?.count > 0) {
                            remaining[tile].count--;
                            remaining[tile2].count--;
                            remaining[tile3].count--;
                            return { type: 'chow', tiles: [tile, tile2, tile3], suit: suit };
                        }
                    }
                }
            }
            return null;
        }

        function addPatterns(hand) {
            const allPongs = hand.melds.every(m => m.type === 'pong' || m.type === 'kong');
            if (allPongs) hand.patterns.push('allPongs');

            const allChow = hand.melds.every(m => m.type === 'chow');
            if (allChow) hand.patterns.push('allChow');

            const suits = new Set();
            const honorCount = hand.melds.filter(m => m.suit === 'dragon' || m.suit === 'wind').length;
            hand.melds.forEach(m => {
                if (m.suit !== 'dragon' && m.suit !== 'wind') suits.add(m.suit);
            });
            if (hand.pair && hand.pair.suit !== 'dragon' && hand.pair.suit !== 'wind') suits.add(hand.pair.suit);

            if (suits.size === 1 && honorCount === 0) hand.patterns.push('pureOneSuit');
            else if (suits.size === 1 && honorCount > 0) hand.patterns.push('mixedOneSuit');

            const dragonPongs = hand.melds.filter(m => m.suit === 'dragon' && (m.type === 'pong' || m.type === 'kong')).length;
            if (dragonPongs === 3) hand.patterns.push('greatDragons');
            else if (dragonPongs === 2 && hand.pair && hand.pair.suit === 'dragon') hand.patterns.push('minorDragons');

            return hand;
        }

        function calculatePayout(faan, isDealer, isSelfDraw) {
            const cappedFaan = Math.min(faan, 13);
            const row = payoutTable[cappedFaan];
            
            let perPlayerAmount;
            if (isDealer && isSelfDraw) perPlayerAmount = row.dealerSelf;
            else if (isDealer && !isSelfDraw) perPlayerAmount = row.dealerDiscard;
            else if (!isDealer && isSelfDraw) perPlayerAmount = row.nonDealerSelf;
            else perPlayerAmount = row.nonDealerDiscard;
            
            if (isSelfDraw) {
                return { total: perPlayerAmount * 3, perPlayer: perPlayerAmount };
            } else {
                return { total: perPlayerAmount, perPlayer: null };
            }
        }

        function getCoinsBreakdown(amount) {
            const coins = [];
            let remaining = amount;
            while (remaining >= 20) { coins.push(20); remaining -= 20; }
            while (remaining >= 10) { coins.push(10); remaining -= 10; }
            while (remaining >= 5) { coins.push(5); remaining -= 5; }
            while (remaining >= 2) { coins.push(2); remaining -= 2; }
            while (remaining >= 1) { coins.push(1); remaining -= 1; }
            return coins;
        }

        function renderCoins(amount) {
            const coins = getCoinsBreakdown(amount);
            return coins.map(coin => `<div class="coin coin-${coin}">${coin}</div>`).join('');
        }

        function updateResultsScreen(points, payout, breakdown, isDealer, isSelfDraw, hand) {
            document.getElementById('winnerName').textContent = (gameState.playerName || 'PLAYER').toUpperCase();

            if (points >= 10) {
                document.getElementById('victoryPhrase').style.display = 'block';
                triggerConfetti();
                setTimeout(() => {
                    document.querySelector('.result-hero').classList.add('victory-glow');
                }, 100);
            } else {
                document.getElementById('victoryPhrase').style.display = 'none';
                document.querySelector('.result-hero').classList.remove('victory-glow');
            }

            document.getElementById('totalPoints').textContent = points;
            
            if (isSelfDraw) {
                document.getElementById('payoutAmount').textContent = `${payout.perPlayer} PP`;
            } else {
                document.getElementById('payoutAmount').textContent = payout.total;
            }
            
            if (isSelfDraw) {
                document.getElementById('payoutDescription').textContent = 'FROM ALL PLAYERS';
            } else {
                document.getElementById('payoutDescription').textContent = 'FROM DISCARDER';
            }
            
            const payoutCoins = document.getElementById('payoutCoins');
            const coinsAmount = isSelfDraw ? payout.perPlayer : payout.total;
            payoutCoins.innerHTML = renderCoins(coinsAmount);
            
            const windMap = { 'east': '東 EAST', 'south': '南 SOUTH', 'west': '西 WEST', 'north': '北 NORTH' };
            const roundWindLabel = windMap[gameState.roundWind];
            const winTypeLabel = isDealer ? 'DEALER' : 'NON-DEALER';
            const winMethodLabel = isSelfDraw ? 'SELF DRAW' : 'DISCARD WIN';
            document.getElementById('winTypeLabel').textContent = `${winTypeLabel} / ${winMethodLabel} / ${roundWindLabel} ROUND`;
            
            // Display tiles (including special hands)
            const resultsTilesDisplay = document.getElementById('resultsTilesDisplay');
            let tilesHTML = '';
            
            // For special hands that don't have standard melds, show all tiles
            if (hand.specialHand) {
                gameState.selectedTiles.forEach(tileObj => {
                    tilesHTML += `<div class="selected-tile ${tileObj.suit}">${tileObj.tile}</div>`;
                });
            } else {
                // Standard hand display
                hand.melds.forEach((meld, index) => {
                    if (index > 0) {
                        tilesHTML += '<div class="tile-divider">|</div>';
                    }
                    meld.tiles.forEach(tile => {
                        tilesHTML += `<div class="selected-tile ${meld.suit}">${tile}</div>`;
                    });
                });
                
                if (hand.pair) {
                    tilesHTML += '<div class="tile-divider">|</div>';
                    hand.pair.tiles.forEach(tile => {
                        tilesHTML += `<div class="selected-tile ${hand.pair.suit}">${tile}</div>`;
                    });
                }
            }
            
            // ADD FLOWERS
            if (gameState.selectedFlowers.length > 0) {
                tilesHTML += '<div class="tile-divider">|</div>';
                gameState.selectedFlowers.forEach(idx => {
                    tilesHTML += `<div class="selected-tile flower">${allTiles.flower[idx]}</div>`;
                });
            }
            
            resultsTilesDisplay.innerHTML = tilesHTML;
            
            // Breakdown
            const breakdownContainer = document.getElementById('breakdownItems');
            let breakdownHTML = '';
            
            const selfDrawItem = breakdown.find(item => item.name.toLowerCase().includes('self draw'));
            const otherItems = breakdown.filter(item => !item.name.toLowerCase().includes('self draw'));
            
            if (selfDrawItem) {
                breakdownHTML += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid rgba(212, 175, 55, 0.2);">
                        <div style="font-size: 11px; color: #2d5016; font-weight: 600; text-transform: uppercase;">${selfDrawItem.name.toUpperCase()}</div>
                        <div style="font-weight: 700; color: #2d5016; font-size: 12px;">+${selfDrawItem.points}</div>
                    </div>
                `;
            }
            
            otherItems.forEach(item => {
                breakdownHTML += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid rgba(212, 175, 55, 0.2);">
                        <div style="font-size: 11px; color: #2d5016; font-weight: 600; text-transform: uppercase;">${item.name.toUpperCase()}</div>
                        <div style="font-weight: 700; color: #2d5016; font-size: 12px;">+${item.points}</div>
                    </div>
                `;
            });
            
            breakdownContainer.innerHTML = breakdownHTML;
            document.getElementById('totalPointsBreakdown').textContent = points;
        }

        function triggerConfetti() {
            const colors = ['#d4af37', '#c83e3e', '#2d5016', '#ffc107', '#dc3545'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 0.5 + 's';
                    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                    document.body.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 4000);
                }, i * 30);
            }
        }

        function backToCalculator() {
            goToScreen('calculatorScreen');
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function resetAndScore() {
            resetCalculator();
            goToScreen('homeScreen');
        }

        function toggleMenu() {
            const overlay = document.getElementById('menuOverlay');
            overlay.classList.toggle('active');
        }

        function closeMenuIfOutside(event) {
            if (event.target.id === 'menuOverlay') {
                toggleMenu();
            }
        }

        function changeName() {
            toggleMenu();
            const newName = prompt('ENTER YOUR NEW NAME:\n(First name + last initial)', gameState.playerName);
            if (newName && newName.trim()) {
                const trimmedName = newName.trim();
                gameState.playerName = trimmedName;
                localStorage.setItem('fourthWallPlayerName', trimmedName);
                document.getElementById('nameEntryForm').style.display = 'none';
                document.getElementById('welcomeBackMessage').style.display = 'block';
                const firstName = trimmedName.split(/[\s.]/)[0];
                document.getElementById('welcomeBackName').textContent = firstName.toUpperCase();
                alert('NAME UPDATED! ✓');
            }
        }

        function goToHistory() {
            toggleMenu();
            goToScreen('historyScreen');
            displayHistory();
        }

        let currentSortMode = 'newest';

        function saveToHistory(points, payout, breakdown, isDealer, isSelfDraw, hand) {
            const historyEntry = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                playerName: gameState.playerName,
                points: points,
                payout: isSelfDraw ? payout.perPlayer : payout.total,
                payoutType: isSelfDraw ? 'perPlayer' : 'total',
                isDealer: isDealer,
                isSelfDraw: isSelfDraw,
                breakdown: breakdown,
                hand: hand,
                seatWind: gameState.seatWind,
                roundWind: gameState.roundWind,
                flowers: gameState.selectedFlowers
            };
            gameState.history.unshift(historyEntry);
            localStorage.setItem('fourthWallHistory', JSON.stringify(gameState.history));
        }

        function displayHistory() {
            const historyList = document.getElementById('historyList');
            const historyEmpty = document.getElementById('historyEmpty');

            if (gameState.history.length === 0) {
                historyList.innerHTML = '';
                historyEmpty.style.display = 'block';
                document.getElementById('totalWins').textContent = '0';
                document.getElementById('highestScore').textContent = '0';
                document.getElementById('totalCoins').textContent = '0';
                return;
            }

            historyEmpty.style.display = 'none';

            const totalWins = gameState.history.length;
            const highestScore = Math.max(...gameState.history.map(h => h.points));
            const totalCoins = gameState.history.reduce((sum, h) => {
                return sum + (h.isSelfDraw ? h.payout * 3 : h.payout);
            }, 0);

            document.getElementById('totalWins').textContent = totalWins;
            document.getElementById('highestScore').textContent = highestScore;
            document.getElementById('totalCoins').textContent = totalCoins;

            let sortedHistory = [...gameState.history];
            if (currentSortMode === 'highest') {
                sortedHistory.sort((a, b) => b.points - a.points);
            }

            historyList.innerHTML = sortedHistory.map(entry => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                const winTypeLabel = entry.isDealer ? 'DEALER' : 'NON-DEALER';
                const winMethodLabel = entry.isSelfDraw ? 'SELF DRAW' : 'DISCARD';
                const badgeColor = entry.points >= 10 ? '#d4af37' : entry.points >= 7 ? '#769656' : '#6c757d';

                return `
                    <div style="background: rgba(248, 245, 230, 0.95); border-radius: 12px; padding: 16px; margin-bottom: 12px; border: 2px solid rgba(212, 175, 55, 0.3);">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                            <div>
                                <div style="font-size: 12px; color: #6c757d; margin-bottom: 4px;">${dateStr} • ${timeStr}</div>
                                <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                                    <span style="background: ${badgeColor}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">${winTypeLabel}</span>
                                    <span style="background: ${badgeColor}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;">${winMethodLabel}</span>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 32px; font-weight: 700; color: #2d5016; line-height: 1;">${entry.points}</div>
                                <div style="font-size: 11px; color: #6c757d;">FAAN</div>
                            </div>
                        </div>
                        <div style="background: rgba(255, 255, 255, 0.6); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="font-size: 13px; font-weight: 600; color: #2d5016;">PAYOUT</div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <div style="font-size: 24px; font-weight: 700; color: #2d5016;">${entry.payout}</div>
                                    ${entry.isSelfDraw ? '<div style="font-size: 11px; color: #6c757d;">PER PLAYER</div>' : ''}
                                </div>
                            </div>
                            <div style="margin-top: 8px; display: flex; gap: 4px; justify-content: flex-end; flex-wrap: wrap;">
                                ${renderCoins(entry.payout)}
                            </div>
                        </div>
                        <div style="font-size: 11px; color: #2d5016; font-weight: 600; margin-bottom: 6px;">SCORING PATTERNS:</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                            ${entry.breakdown.map(item => `
                                <div style="background: white; padding: 6px 10px; border-radius: 6px; font-size: 11px; display: flex; align-items: center; gap: 6px; border: 1px solid #e1e4e8;">
                                    <span style="color: #2d5016; font-weight: 600;">${item.name}</span>
                                    <span style="color: #769656; font-weight: 700;">+${item.points}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function sortHistory(mode) {
            currentSortMode = mode;
            const newestBtn = document.getElementById('sortNewest');
            const highestBtn = document.getElementById('sortHighest');
            
            if (mode === 'newest') {
                newestBtn.style.background = '#769656';
                newestBtn.style.color = 'white';
                newestBtn.style.border = 'none';
                highestBtn.style.background = '#f8f9fa';
                highestBtn.style.color = '#6c757d';
                highestBtn.style.border = '2px solid #e1e4e8';
            } else {
                highestBtn.style.background = '#769656';
                highestBtn.style.color = 'white';
                highestBtn.style.border = 'none';
                newestBtn.style.background = '#f8f9fa';
                newestBtn.style.color = '#6c757d';
                newestBtn.style.border = '2px solid #e1e4e8';
            }
            
            displayHistory();
        }
    </script>
</body>
</html>
